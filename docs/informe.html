<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="es" xml:lang="es">
<head>
<!-- 2025-10-09 Thu 19:11 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>&lrm;</title>
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="assets/theme/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="assets/theme/readtheorg_theme/css/readtheorg.css"/>
<link rel="stylesheet" type="text/css" href="assets/theme/readtheorg_theme/css/search.css"/>
<script type="text/javascript" src="assets/theme/lib/js/jquery.min.js"></script>
<script type="text/javascript" src="assets/theme/lib/js/bootstrap.min.js"></script>
<script type="text/javascript" src="assets/theme/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="assets/theme/readtheorg_theme/js/search.js"></script>
<script type="text/javascript" src="assets/theme/readtheorg_theme/js/readtheorg.js"></script>
<script type="text/javascript">disableSearch();</script>
</head>
<body>
<div id="content" class="content">
<div id="table-of-contents" role="doc-toc">
<h2>&Iacute;ndice</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgad0a384">1. Introducción</a></li>
<li><a href="#org2ce0006">2. Atributos de calidad (QA) claves identificados</a>
<ul>
<li><a href="#orgc052ac2">2.1. Disponibilidad</a></li>
<li><a href="#orgedf0777">2.2. Escalabilidad (Elasticidad)</a></li>
<li><a href="#orge4992e8">2.3. Performance</a></li>
<li><a href="#orgc448c09">2.4. Visibilidad</a></li>
</ul>
</li>
<li><a href="#orgf644abb">3. Arquitectura base</a>
<ul>
<li><a href="#org8bcc858">3.1. Análisis de la influencia de decisiones de diseño en los QA's</a></li>
<li><a href="#org2a33906">3.2. Incorporación del stack de monitoreo cAdvisor + Artillery + StatsD + Graphite + Grafana</a>
<ul>
<li><a href="#orgee10ee6">3.2.1. Impactos identificados</a></li>
</ul>
</li>
<li><a href="#org9cfb744">3.3. Impactos del modelo de persistencia elegido</a></li>
<li><a href="#org5a48e80">3.4. Instancias únicas de cada servicio</a></li>
<li><a href="#orgec8f657">3.5. Ausencia de un patrón de arquitectura interna</a></li>
<li><a href="#orgc7a9d03">3.6. Diagrama C&amp;C inicial.</a></li>
<li><a href="#org56d9447">3.7. Crítica a arquitectura base.</a></li>
</ul>
</li>
<li><a href="#org9a81bd8">4. Metodología de pruebas</a>
<ul>
<li><a href="#orgfd5d45e">4.1. Recolección de datos</a>
<ul>
<li><a href="#orgb163db2">4.1.1. Graphit + Grafana</a></li>
<li><a href="#org622a56f">4.1.2. StatsD (métricas custom)</a></li>
<li><a href="#org4fbcc12">4.1.3. DataDog (logs + métricas etiquetadas)</a></li>
<li><a href="#org1fb271a">4.1.4. DataDog (dashboard)</a></li>
</ul>
</li>
<li><a href="#org7dbefba">4.2. Generación de carga</a></li>
</ul>
</li>
<li><a href="#orgf12670a">5. Resultados – Caso base</a>
<ul>
<li><a href="#orgb3db0df">5.1. Análisis del endpoint Rates</a>
<ul>
<li><a href="#orga5cd1f1">5.1.1. Prueba con carga baja</a></li>
<li><a href="#org31aad64">5.1.2. Prueba con mayor carga</a></li>
<li><a href="#org3d1508c">5.1.3. Resumen de métricas de Artillery</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org9576afb">6. Propuestas de mejora</a>
<ul>
<li><a href="#orgd0a5bec">6.1. Implementacion de Valkey como persistencia</a>
<ul>
<li><a href="#orgb1ec94d">6.1.1. Tactica aplicada</a></li>
<li><a href="#org13b5ce1">6.1.2. Configuracion</a></li>
<li><a href="#org25b5022">6.1.3. Beneficios</a></li>
</ul>
</li>
<li><a href="#org3b9166c">6.2. Implementacion de PostgreSQL como persistencia</a>
<ul>
<li><a href="#org8dce938">6.2.1. Tactica aplicada</a></li>
<li><a href="#org0b23335">6.2.2. Configuracion</a></li>
<li><a href="#orgd1feacc">6.2.3. Beneficios</a></li>
</ul>
</li>
<li><a href="#org032b3e5">6.3. Comparacion de estados de requests</a></li>
</ul>
</li>
<li><a href="#org40f32f4">7. Trade-offs detectados.</a></li>
<li><a href="#org72d4ab6">8. Pedido Adicional (Volumen de transacciones por moneda)</a></li>
<li><a href="#orgae037ba">9. Conclusiones</a></li>
</ul>
</div>
</div>
<div id="outline-container-orgad0a384" class="outline-2">
<h2 id="orgad0a384"><span class="section-number-2">1.</span> Introducción</h2>
<div class="outline-text-2" id="text-1">
<p>
arVault es una startup fintech que opera una billetera digital con un enfoque en ofrecer tasas de cambio competitivas para operaciones entre distintas monedas. En un contexto donde la confianza del usuario es fundamental, la empresa se enfrenta al desafío de mejorar su servicio de cambio de divisas tras recibir múltiples reclamos por problemas de rendimiento y disponibilidad.
</p>

<p>
El presente trabajo se enmarca en la necesidad de arVault de realizar una auditoría exhaustiva de su arquitectura actual para identificar oportunidades de mejora en los atributos de calidad del sistema. Este análisis resulta crucial para la empresa, ya que su capacidad de atraer nuevas inversiones depende directamente de la confiabilidad y desempeño de su plataforma.
</p>

<p>
Los objetivos principales de este trabajo práctico son:
</p>

<ol class="org-ol">
<li>Analizar la arquitectura actual del sistema de cambio de divisas.</li>
<li>Identificar los atributos de calidad críticos para el negocio.</li>
<li>Evaluar el impacto de las decisiones de diseño en dichos atributos.</li>
<li>Proponer e implementar mejoras basadas en tácticas arquitectónicas.</li>
<li>Medir y comparar el rendimiento antes y después de las modificaciones.</li>
</ol>

<p>
El alcance del análisis abarca tanto aspectos técnicos como de negocio, considerando la infraestructura existente (Node.js, Express, Nginx, etc) y las herramientas de monitoreo implementadas (cAdvisor, StatsD, Graphite, Grafana). Se prestará especial atención a métricas clave como el volumen de operaciones por moneda y el neto de transacciones, tal como lo solicitó el fundador de arVault.
</p>

<p>
Este informe documenta nuestro proceso de análisis, las decisiones tomadas y los resultados obtenidos, con el fin de proporcionar recomendaciones fundamentadas que permitan a arVault mejorar la calidad de su servicio y recuperar la confianza de sus usuarios e inversores.
</p>
</div>
</div>
<div id="outline-container-org2ce0006" class="outline-2">
<h2 id="org2ce0006"><span class="section-number-2">2.</span> Atributos de calidad (QA) claves identificados</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-orgc052ac2" class="outline-3">
<h3 id="orgc052ac2"><span class="section-number-3">2.1.</span> Disponibilidad</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Al ser un servicio de exchange de monedas, asumimos que es un servicio que se utiliza durante todos los dias habiles de la semana en horario cambiario. Por lo tanto, es importante que el servicio se encuentre disponible durante esos horarios para no perder clientes.
</p>

<p>
Además, dado el contexto en el que queremos recuperar la confianza de los usuarios y remontar la reputación, el sistema debe ser altamente accesible para los usuarios y permitir realizar correctamente sus operaciones respetando tiempos razonables de respuesta.
</p>
</div>
</div>
<div id="outline-container-orgedf0777" class="outline-3">
<h3 id="orgedf0777"><span class="section-number-3">2.2.</span> Escalabilidad (Elasticidad)</h3>
<div class="outline-text-3" id="text-2-2">
<p>
La escalabilidad, y en particular la elasticidad, constituyen un atributo de calidad crítico para el servicio de intercambios de arVault. Esto se debe a que la infraestructura del sistema debe ser capaz de adaptarse dinámicamente a variaciones en la demanda de usuarios.
</p>

<p>
En el contexto del negocio, es esperable la aparición de picos significativos de demanda en momentos específicos (por ejemplo, en la apertura y cierre del horario cambiario), así como también períodos de baja o nula actividad. A ello se suma que, dado que el servicio busca captar rápidamente un gran volumen de nuevos usuarios, especialmente tras campañas de promoción destinadas a revertir percepciones negativas de experiencias pasadas, existe el riesgo de enfrentar aumentos inesperados de tráfico.
</p>

<p>
Si el sistema careciera de elasticidad, estos picos de operaciones de cambio de moneda podrían derivar en saturación de recursos, lo que a su vez ocasionaría demoras, rechazos de transacciones o caídas del servicio. Dichos incidentes afectarían de manera directa la reputación de la empresa, un aspecto considerado prioritario en función de los objetivos actuales y de las expectativas de los stakeholders.
</p>
</div>
</div>
<div id="outline-container-orge4992e8" class="outline-3">
<h3 id="orge4992e8"><span class="section-number-3">2.3.</span> Performance</h3>
<div class="outline-text-3" id="text-2-3">
<p>
El atributo de calidad Performance, y en particular el User-Perceived Performance, adquiere relevancia crítica en el servicio de intercambio de monedas de arVault, para sustentar esta afirmación nos basamos en el siguiente análisis del contexto y antecedentes brindados:
</p>

<p>
Tras el lanzamiento de la funcionalidad, se registraron reclamos de usuarios relacionados con demoras y fallas en la ejecución de operaciones de cambio, lo que ha derivado en reseñas negativas y pérdida de confianza en la plataforma. En un contexto donde la empresa necesita con urgencia atraer nuevas rondas de inversión, estas deficiencias de rendimiento representan un riesgo directo, ya que los potenciales inversores han condicionado su apoyo a la realización de mejoras en la calidad del servicio.
</p>

<p>
En una aplicación financiera, la percepción de agilidad y confiabilidad en la respuesta del sistema es esencial: tiempos de espera excesivos o transacciones fallidas afectan la experiencia de los usuarios y minan la credibilidad de la plataforma. Aunque el diferencial de arVault reside en ofrecer tasas de cambio más convenientes que la competencia, dicho valor se ve neutralizado si el servicio de intercambio no responde con la rapidez y estabilidad que los clientes esperan.
</p>

<p>
Por ello, la mejora del User-Perceived Performance se presenta como un paso imprescindible no solo para recuperar la confianza de los usuarios actuales, sino también para restaurar la reputación de la empresa ante el mercado y viabilizar la captación de nuevos inversores, garantizando así la continuidad y evolución del negocio.
</p>
</div>
</div>
<div id="outline-container-orgc448c09" class="outline-3">
<h3 id="orgc448c09"><span class="section-number-3">2.4.</span> Visibilidad</h3>
<div class="outline-text-3" id="text-2-4">
<p>
El valor de este atributo de calidad es más indirecto pero estratégico pues permite entender el comportamiento real del sistema, identificar cuellos de botella de performance, localizar errores en operaciones de cambio y detectar patrones de saturación que anticipen problemas de disponibilidad o escalabilidad. Es decir, la visibilidad no impacta de forma inmediata en la experiencia del usuario, pero habilita a los arquitectos y al equipo técnico a diagnosticar, mejorar y sostener los otros atributos de calidad prioritarios.
</p>
</div>
</div>
</div>
<div id="outline-container-orgf644abb" class="outline-2">
<h2 id="orgf644abb"><span class="section-number-2">3.</span> Arquitectura base</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-org8bcc858" class="outline-3">
<h3 id="org8bcc858"><span class="section-number-3">3.1.</span> Análisis de la influencia de decisiones de diseño en los QA's</h3>
<div class="outline-text-3" id="text-3-1">
<p>
En la presente sección se explorarán las decisiones de diseño identificadas en la arquitectura base y su impacto sobre los atributos de calidad estudiados.
</p>
</div>
</div>
<div id="outline-container-org2a33906" class="outline-3">
<h3 id="org2a33906"><span class="section-number-3">3.2.</span> Incorporación del stack de monitoreo cAdvisor + Artillery + StatsD + Graphite + Grafana</h3>
<div class="outline-text-3" id="text-3-2">
<p>
El sistema actual presenta un stack de observabilidad para medir, almacenar y visualizar métricas en tiempo real. En concreto:
</p>
<ul class="org-ul">
<li>cAdvisor: mide métricas de contenedores (CPU, memoria, etc.)</li>
<li>Artillery: genera carga (testing de rendimiento)</li>
<li>StatsD + Graphite: recolectan y almacenan métricas</li>
<li>Grafana: visualiza las métricas</li>
</ul>

<p>
Esta decisión implicó agregar tres nuevos contenedores, configuraciones adicionales, puertos, conexiones en red internas de Docker y dependencias entre servicios, lo cual impactó de diferentes formas a distintos <b>stakeholders</b>.
</p>
</div>
<div id="outline-container-orgee10ee6" class="outline-4">
<h4 id="orgee10ee6"><span class="section-number-4">3.2.1.</span> Impactos identificados</h4>
<div class="outline-text-4" id="text-3-2-1">
<ul class="org-ul">
<li><b>Carga cognitiva alta:</b>  
Implicó que desarrolladores y arquitectos del sistema deban comprender cómo se conectan las herramientas, qué hace cada una y cómo interpretar los datos generados.  
Esto impacta la <b>usabilidad interna</b> (para el desarrollador), la <b>manejabilidad</b> y la <b>simplicidad</b> del sistema, que originalmente se componía solo de un backend y un proxy inverso (Nginx).</li>

<li><b>Complejidad operativa:</b>  
Más contenedores implican más puertos, configuraciones y <b>logs</b> extensos (en particular en el entorno local del trabajo práctico), lo cual aumenta el esfuerzo de <b>debugging</b> y de gestión general.  
Esto afecta negativamente la <b>manejabilidad</b>, dado que se incrementa la complejidad operativa y el tiempo requerido para mantener el sistema.</li>

<li><b>Evaluación y visibilidad del comportamiento del sistema:</b>  
Cuando el stack se encuentra correctamente configurado, las métricas permiten monitorear el rendimiento, detectar cuellos de botella y observar cómo interactúan los distintos componentes.  
Esto mejora la <b>visibilidad</b> del sistema y favorece la <b>confiabilidad</b>, ya que permite anticipar fallos o anomalías de comportamiento.  
No obstante, la dependencia entre múltiples herramientas introduce el riesgo de obtener una visibilidad incompleta si alguno de los servicios del stack (por ejemplo, Graphite o StatsD) deja de funcionar.</li>

<li><b>Afectación a la disponibilidad:</b>  
El aumento en la cantidad de servicios dependientes implica más puntos de falla. Si Graphite o StatsD se detienen, Grafana dejará de mostrar información actualizada.  
Además, el tiempo de despliegue y recuperación ante fallos se incrementa, afectando la <b>disponibilidad</b> de manera negativa, sobre todo en entornos locales.</li>

<li><b>Apoyo a la testeabilidad y diagnóstico:</b>  
El stack de monitoreo potencia la capacidad de análisis durante pruebas de rendimiento (por ejemplo, al utilizar Artillery y observar las métricas en Grafana).  
Esto facilita la identificación de comportamientos anómalos y la validación de la estabilidad del sistema, mejorando la <b>testeabilidad</b>.  
Sin embargo, la infraestructura adicional necesaria para habilitar el monitoreo también introduce complejidad en el entorno de prueba, lo que puede dificultar la reproducibilidad y el control de los experimentos.</li>

<li><b>Seguridad y aislamiento:</b>  
Añadir más servicios amplía la superficie de ataque, ya que cada contenedor es un proceso escuchando en distintos puertos internos.  
Esto impacta la <b>seguridad operativa</b>, aunque su efecto sea poco relevante en entornos locales de desarrollo.</li>

<li><b>Impacto en la portabilidad del sistema:</b>  
La containerización permite desplegar el stack completo en distintos entornos con relativa facilidad, lo cual favorece la <b>portabilidad técnica</b>.  
Sin embargo, la fuerte interdependencia entre servicios y las configuraciones específicas de red, puertos y volúmenes reducen la <b>portabilidad práctica</b>, dado que pequeñas diferencias en la infraestructura pueden afectar el funcionamiento o requerir ajustes manuales.</li>

<li><b>Interoperabilidad y acoplamiento tecnológico:</b>  
El uso de protocolos y herramientas estandarizadas (UDP, HTTP, Grafana, StatsD) favorece la <b>interoperabilidad</b> del sistema, tanto entre sus propios componentes como con futuras herramientas externas de monitoreo.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org9cfb744" class="outline-3">
<h3 id="org9cfb744"><span class="section-number-3">3.3.</span> Impactos del modelo de persistencia elegido</h3>
<div class="outline-text-3" id="text-3-3">
<p>
El modelo de persistencia implementado en el sistema consiste en mantener en memoria el estado de los datos y, periódicamente, volcar dicho estado a archivos JSON almacenados localmente en la carpeta <code>~/state/~</code>.  
Esto implica que la persistencia está acoplada directamente a la instancia del servidor —es decir, se trata de un sistema *stateful*—, lo que conlleva una serie de consecuencias relevantes sobre diversos atributos de calidad.
</p>

<ul class="org-ul">
<li><b>Acoplamiento con la instancia del servidor:</b>  
Al vincular el estado con una única instancia, las sesiones de usuario y los datos persistentes no pueden compartirse entre instancias.  
Esto impide la <b>escalabilidad horizontal</b>, dado que cada réplica tendría su propio estado local no sincronizado. Implementar una gestión de estado distribuido requeriría una infraestructura adicional (por ejemplo, una base de datos externa o un servicio de caché compartido).</li>

<li><b>Impacto en la disponibilidad y rendimiento percibido:</b>  
La existencia de una única instancia con estado convierte al backend en un <b>punto único de falla</b>.  
Si el servidor se detiene, todas las sesiones activas se pierden y no pueden ser recuperadas por otra instancia.  
Esto afecta la <b>disponibilidad</b> y la <b>experiencia del usuario</b>, ya que aumenta la percepción de fallas y degradación del rendimiento.</li>

<li><b>Problemas de concurrencia:</b>  
Al utilizar el sistema de archivos local como medio de persistencia, se introducen <b>condiciones de carrera</b> durante operaciones de lectura y escritura concurrentes.  
El modelo de concurrencia de Node.js (basado en asincronía) no resulta suficiente para garantizar consistencia, dado que el file system no ofrece bloqueo ni sincronización de accesos concurrentes.  
Esto impacta negativamente la <b>confiabilidad</b> y la <b>consistencia de datos</b>.</li>

<li><b>Ausencia de soporte transaccional:</b>  
El modelo carece de transacciones, por lo que las operaciones no son atómicas ni recuperables ante fallos.  
En caso de interrupciones durante la escritura, el sistema puede quedar en estados inconsistentes o requerir restauraciones manuales.  
Esto degrada tanto la <b>disponibilidad</b> como la <b>recuperabilidad</b>.</li>

<li><b>Pérdida de integridad de datos:</b>  
La falta de atomicidad en las operaciones puede dejar al sistema en estados inválidos (por ejemplo, inconsistencias en saldos o cantidades totales).  
En consecuencia, la <b>integridad</b> del sistema se ve directamente comprometida.</li>

<li><b>Incompatibilidad con balanceo de carga:</b>  
Dado que el modelo de persistencia no soporta replicación, la existencia de un balanceador de carga (como Nginx) se vuelve una decisión cuestionable.  
No existen múltiples backends entre los cuales distribuir tráfico, y el balanceador introduce una capa de comunicación adicional que <b>degrada el rendimiento</b> sin aportar beneficios reales.</li>
</ul>

<p>
En conjunto, este modelo de persistencia afecta negativamente la <b>disponibilidad</b>, la <b>escalabilidad</b>, la <b>integridad</b> y la <b>mantenibilidad</b>, al tiempo que incrementa la <b>complejidad operativa</b> y el riesgo de errores durante la evolución del sistema.
</p>
</div>
</div>
<div id="outline-container-org5a48e80" class="outline-3">
<h3 id="org5a48e80"><span class="section-number-3">3.4.</span> Instancias únicas de cada servicio</h3>
<div class="outline-text-3" id="text-3-4">
<p>
El sistema fue diseñado de manera que cada servicio (API, proxy inverso Nginx, almacenamiento local, etc.) cuenta con una única instancia activa.  
Esta decisión genera <b>múltiples puntos únicos de falla</b> y limita severamente la capacidad del sistema para mantener su operación ante fallos parciales.
</p>

<ul class="org-ul">
<li>Si cualquiera de estos servicios se detiene, el sistema completo se vuelve <b>indisponible</b>, afectando directamente la <b>disponibilidad</b> y la <b>tolerancia a fallos</b>.</li>
<li>La ausencia de mecanismos automáticos de recuperación o reinicio (como <b>health checks</b>, <b>watchdogs</b> o políticas de <b>restart</b> configuradas en Docker) agrava el impacto de las fallas, ya que se requiere intervención manual para restablecer el servicio.</li>
<li>Tampoco existen estrategias de <b>replicación</b>, <b>balanceo</b> ni <b>redundancia</b>, lo que hace imposible sostener niveles de servicio adecuados bajo carga o ante degradación de componentes.</li>
</ul>

<p>
Esta configuración puede ser suficiente para entornos de desarrollo o demostración, pero resulta <b>inadecuada para entornos de producción</b>, donde la <b>disponibilidad</b>, <b>resiliencia</b> y <b>recuperabilidad</b> son atributos esenciales.
</p>
</div>
</div>
<div id="outline-container-orgec8f657" class="outline-3">
<h3 id="orgec8f657"><span class="section-number-3">3.5.</span> Ausencia de un patrón de arquitectura interna</h3>
<div class="outline-text-3" id="text-3-5">
<p>
El sistema carece de un patrón de arquitectura claramente definido a nivel interno (por ejemplo, MVC, capas o microservicios), lo cual genera una estructura <b>monolítica y fuertemente acoplada</b>.  
Esta decisión afecta negativamente atributos clave del sistema relacionados con su evolución y mantenibilidad.
</p>

<ul class="org-ul">
<li><b>Dificultad para modificar o extender funcionalidades:</b>  
La ausencia de separación de responsabilidades y de interfaces desacopladas complica la incorporación de nuevas funcionalidades (<b>extensibilidad</b>) o la modificación segura de las existentes (<b>modificabilidad</b>).</li>

<li><b>Incremento en la complejidad del código:</b>  
La lógica de negocio, de presentación y de persistencia tienden a mezclarse, lo que eleva la <b>complejidad cognitiva</b> y el riesgo de introducir errores.</li>

<li><b>Falta de testabilidad:</b>  
Al no existir módulos claramente delimitados, las pruebas unitarias o de integración se vuelven difíciles de implementar, afectando la <b>testeabilidad</b> del sistema.</li>

<li><b>Escasa capacidad de evolución:</b>  
La arquitectura monolítica limita la posibilidad de migrar gradualmente a tecnologías más modernas o de reestructurar componentes de forma incremental.</li>
</ul>

<p>
En conjunto, esta ausencia de estructura arquitectónica limita la <b>mantenibilidad</b>, <b>evolutividad</b>, <b>testeabilidad</b> y <b>extensibilidad</b>, dificultando la gestión del ciclo de vida del software.
</p>
</div>
</div>
<div id="outline-container-orgc7a9d03" class="outline-3">
<h3 id="orgc7a9d03"><span class="section-number-3">3.6.</span> Diagrama C&amp;C inicial.</h3>
<div class="outline-text-3" id="text-3-6">

<div id="org70b22eb" class="figure">
<p><img src="assets/componentes.png" alt="componentes.png" />
</p>
</div>
</div>
</div>
<div id="outline-container-org56d9447" class="outline-3">
<h3 id="org56d9447"><span class="section-number-3">3.7.</span> Crítica a arquitectura base.</h3>
</div>
</div>
<div id="outline-container-org9a81bd8" class="outline-2">
<h2 id="org9a81bd8"><span class="section-number-2">4.</span> Metodología de pruebas</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-orgfd5d45e" class="outline-3">
<h3 id="orgfd5d45e"><span class="section-number-3">4.1.</span> Recolección de datos</h3>
<div class="outline-text-3" id="text-4-1">
</div>
<div id="outline-container-orgb163db2" class="outline-4">
<h4 id="orgb163db2"><span class="section-number-4">4.1.1.</span> Graphit + Grafana</h4>
</div>

<div id="outline-container-org622a56f" class="outline-4">
<h4 id="org622a56f"><span class="section-number-4">4.1.2.</span> StatsD (métricas custom)</h4>
<div class="outline-text-4" id="text-4-1-2">
<p>
En la app se agregaron métricas propias con <code>hot-shots</code> (cliente StatsD/DogStatsD) usando el prefijo <code>arvault.</code>. Se emiten en dos puntos: (a) middleware HTTP para latencia y throughput, y (b) lógica de negocio del exchange para volumen y estado de las operaciones.
</p>

<ul class="org-ul">
<li>HTTP (Performance)
<ul class="org-ul">
<li><code>arvault.api.response_time</code> (<b>timing</b>, ms): latencia por request medida en el middleware. Útil para ver p50/p95/p99 y detectar degradaciones bajo carga.</li>
<li><code>arvault.api.requests</code> (<b>counter</b>): throughput de la API. Sirve para correlacionar picos de tráfico con cambios en latencia y calcular tasas (p. ej., error rate).</li>
</ul></li>

<li>Negocio (Visibilidad, Disponibilidad proxy)
<ul class="org-ul">
<li><code>arvault.exchange.transactions</code> (<b>counter</b>): total de operaciones de intercambio. Base para segmentar por par de monedas y estado.
<ul class="org-ul">
<li><code>arvault.exchange.successful_transactions</code> (<b>counter</b>): operaciones exitosas; permite estimar disponibilidad efectiva percibida.</li>
<li><code>arvault.exchange.failed_transactions</code> (<b>counter</b>): operaciones fallidas; se usa con la anterior para ver el ratio de fallas.</li>
</ul></li>
<li><code>arvault.exchange.base_amount</code> / <code>arvault.exchange.counter_amount</code> (<b>gauge</b>): montos de la operación en moneda base y contraparte. Ayudan a entender volumen económico y detectar outliers.</li>
<li><code>arvault.exchange.rate</code> (<b>gauge</b>): tasa aplicada al momento del intercambio. Útil para auditar cambios de precio y drift respecto de configuraciones.</li>
<li><code>arvault.volume.by_currency</code> (<b>gauge</b>): volumen por <code>currency</code> y <code>operation</code> (<code>buy/sell</code>). Indica monedas demandadas y patrones de demanda.</li>
<li><code>arvault.volume.operations_count</code> (<b>counter</b>): cantidad de operaciones por dimensión de volumen; complementa el gauge para ver frecuencia sin importar el monto.</li>
<li><code>arvault.volume.net</code> (<b>gauge</b>): balance neto por moneda (positivo en <code>buy</code>, negativo en <code>sell</code>). Sirve para monitorear exposición neta / liquidez.</li>
<li><code>arvault.account.balance</code> (<b>gauge</b>): balances reportados por cuenta/moneda. Útil para verificar disponibilidad de fondos y umbrales operativos.</li>
</ul></li>

<li>Errores (Confiabilidad)
<ul class="org-ul">
<li><code>arvault.errors.count</code> (<b>counter</b>)</li>
</ul></li>
</ul>

<p>
Las métricas incluyen <b>tags</b> según el caso (p. ej., <code>endpoint</code>, <code>method</code>, <code>status_code</code>, <code>currency</code>, <code>operation</code>, <code>base_currency</code>, <code>counter_currency</code>, <code>success</code>, y metadatos globales <code>service</code>, <code>env</code>). Estas señales se usan luego para contrastar escenarios de carga y fundamentar observaciones sobre <b><b>Performance</b></b>, <b><b>Disponibilidad</b></b> y <b><b>Visibilidad</b></b>.
</p>
</div>
</div>
<div id="outline-container-org4fbcc12" class="outline-4">
<h4 id="org4fbcc12"><span class="section-number-4">4.1.3.</span> DataDog (logs + métricas etiquetadas)</h4>
<div class="outline-text-4" id="text-4-1-3">
<p>
Se habilitó <b><b>logging estructurado</b></b> y el envío de <b><b>métricas etiquetadas</b></b> compatibles con DogStatsD.
</p>

<ul class="org-ul">
<li>Logs JSON con <code>winston</code>
<ul class="org-ul">
<li>Formato: <code>timestamp</code>, captura de <code>errors({ stack: true })</code>, y <code>defaultMeta</code> (<code>service</code>, <code>env</code>, <code>version</code>).</li>
<li>Registros implementados:
<ul class="org-ul">
<li><code>logRequest</code>: método, URL/path, <code>status_code</code>, <code>response_time</code>, <code>user_agent</code>, IP, <code>request_id</code>.</li>
<li><code>logValidationError</code>: errores de entrada (tipo, mensaje, <code>endpoint</code>, <code>request_data</code>).</li>
<li><code>logSystemError</code>: fallas internas (mensaje, <code>stack</code>, nombre de error, <code>context</code>).</li>
<li><code>logExchangeTransaction</code>: resultado de intercambio (ok/falla), IDs de cuentas, monedas, montos, <code>exchange_rate</code>, mensaje de error si aplica.</li>
<li><code>logPerformance</code>: duración de operaciones puntuales.</li>
<li><code>logLifecycleEvent</code>: eventos de ciclo de vida (ej., <code>startup</code>).</li>
</ul></li>
</ul></li>

<li>Métricas con <b>tags</b> (DogStatsD)
<ul class="org-ul">
<li>Las métricas <code>arvault.*</code> anteriores se envían con <b>tags</b> (p. ej., <code>endpoint</code>, <code>method</code>, <code>status_code</code>, <code>currency</code>, <code>operation</code>, <code>base_currency</code>, <code>counter_currency</code>, <code>success</code>, además de <code>service</code>, <code>env</code>, <code>version</code>).</li>
<li>Esto permite segmentar los indicadores de <b><b>Performance</b></b> y <b><b>Visibilidad</b></b> por dimensiones de negocio y técnicas.</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org1fb271a" class="outline-4">
<h4 id="org1fb271a"><span class="section-number-4">4.1.4.</span> DataDog (dashboard)</h4>
<div class="outline-text-4" id="text-4-1-4">
<p>
Armamos un dashboard simple para entender las fallas criticas del servicio y ademas entender el dominio del negocio. La idea es cubrir tres frentes a la vez: <b><b>Performance</b></b> (qué tan rápido respondemos), <b><b>Disponibilidad/Confiabilidad</b></b> (qué tan seguido falla) y <b><b>Visibilidad</b></b> (qué parte del negocio está más activa).
</p>
</div>
<ol class="org-ol">
<li><a id="org9ea5d17"></a>Requests per endpoint<br />
<div class="outline-text-5" id="text-4-1-4-1">
<p>
Cuántas llamadas recibe cada ruta. Con esto vemos cuáles son las más usadas y dónde conviene poner foco de capacidad.
</p>

<div id="orga3bf394" class="figure">
<p><img src="assets/db-02-requests-by-endpoint.png" alt="db-02-requests-by-endpoint.png" />
</p>
<p><span class="figure-number">Figura 1: </span>Requests por endpoint</p>
</div>
</div>
</li>
<li><a id="orgc904158"></a>Status Codes Distribution<br />
<div class="outline-text-5" id="text-4-1-4-2">
<p>
La mezcla de 200/4xx/5xx a lo largo del tiempo. Es nuestro termómetro de salud: muchos 5xx = algo se rompió del lado servidor; pico de 4xx = validaciones/UX para revisar.
</p>

<div id="org063381d" class="figure">
<p><img src="assets/db-03-status-codes.png" alt="db-03-status-codes.png" />
</p>
<p><span class="figure-number">Figura 2: </span>Distribución de status codes</p>
</div>
</div>
</li>
<li><a id="orgce49a78"></a>Exchange – Success rate<br />
<div class="outline-text-5" id="text-4-1-4-3">
<p>
Porcentaje de transacciones que salen bien vs. fallan. Cuando baja, impacta directo al negocio y hay que mirar lógica y dependencias.
</p>

<div id="org0c9c605" class="figure">
<p><img src="assets/db-04-exchange-success-rate.png" alt="db-04-exchange-success-rate.png" />
</p>
<p><span class="figure-number">Figura 3: </span>Tasa de éxito de transacciones de exchange</p>
</div>
</div>
</li>
<li><a id="orgb9de272"></a>Exchange – Total transactions<br />
<div class="outline-text-5" id="text-4-1-4-4">
<p>
Volumen bruto de operaciones. Útil para ver actividad, comparar días y estimar capacidad necesaria.
</p>

<div id="org2f453cc" class="figure">
<p><img src="assets/db-05-exchange-total.png" alt="db-05-exchange-total.png" />
</p>
<p><span class="figure-number">Figura 4: </span>Total de transacciones de exchange</p>
</div>
</div>
</li>
<li><a id="orgfb7d219"></a>Volume by currency<br />
<div class="outline-text-5" id="text-4-1-4-5">
<p>
Cuánta actividad concentra cada moneda (USD, ARS, EUR, …). Ayuda con liquidez y prioridades: dónde hay más movimiento, ahí hay más riesgo/atención.
</p>

<div id="org668c9c5" class="figure">
<p><img src="assets/db-06-volume-by-currency.png" alt="db-06-volume-by-currency.png" />
</p>
<p><span class="figure-number">Figura 5: </span>Volumen por moneda</p>
</div>
</div>
</li>
<li><a id="org4394f1e"></a>Net volume by currency<br />
<div class="outline-text-5" id="text-4-1-4-6">
<p>
Compras menos ventas por moneda. Si el neto de USD es muy negativo, estamos vendiendo más de lo que compramos: ojo con la posición.
</p>

<div id="orga37f2b5" class="figure">
<p><img src="assets/db-07-net-volume-by-currency.png" alt="db-07-net-volume-by-currency.png" />
</p>
<p><span class="figure-number">Figura 6: </span>Volumen neto por moneda</p>
</div>
</div>
</li>
<li><a id="org720c277"></a>Exchange rates<br />
<div class="outline-text-5" id="text-4-1-4-7">
<p>
Las tasas vigentes por par. Sirve para chequear precios, detectar volatilidad y cuidar márgenes.
</p>

<div id="org935187a" class="figure">
<p><img src="assets/db-08-exchange-rates.png" alt="db-08-exchange-rates.png" />
</p>
<p><span class="figure-number">Figura 7: </span>Tasas de cambio por par</p>
</div>
</div>
</li>
<li><a id="orgd16f3ad"></a>Error count por tipo<br />
<div class="outline-text-5" id="text-4-1-4-8">
<p>
Los errores agrupados por categoría (p. ej., <code>validation_error</code>, <code>exchange_failed</code>). Da pista rápida de dónde conviene atacar: UX/validaciones o lógica interna.
</p>

<div id="org8cde315" class="figure">
<p><img src="assets/db-10-error-count-by-type.png" alt="db-10-error-count-by-type.png" />
</p>
<p><span class="figure-number">Figura 8: </span>Conteo de errores por tipo</p>
</div>
</div>
</li>
<li><a id="orga580261"></a>KPIs de resumen<br />
<div class="outline-text-5" id="text-4-1-4-9">
<p>
Un par de tarjetas con lo esencial: throughput, total de transacciones y total de errores. Es la vista “de un vistazo” para status diario y alertas.
</p>

<div id="orga334af9" class="figure">
<p><img src="assets/db-12-15-summary-kpis.png" alt="db-12-15-summary-kpis.png" />
</p>
<p><span class="figure-number">Figura 9: </span>KPIs de resumen (requests, transacciones, errores)</p>
</div>
</div>
</li>
</ol>
</div>
</div>
<div id="outline-container-org7dbefba" class="outline-3">
<h3 id="org7dbefba"><span class="section-number-3">4.2.</span> Generación de carga</h3>
</div>
</div>
<div id="outline-container-orgf12670a" class="outline-2">
<h2 id="orgf12670a"><span class="section-number-2">5.</span> Resultados – Caso base</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-orgb3db0df" class="outline-3">
<h3 id="orgb3db0df"><span class="section-number-3">5.1.</span> Análisis del endpoint Rates</h3>
<div class="outline-text-3" id="text-5-1">
</div>
<div id="outline-container-orga5cd1f1" class="outline-4">
<h4 id="orga5cd1f1"><span class="section-number-4">5.1.1.</span> Prueba con carga baja</h4>
<div class="outline-text-4" id="text-5-1-1">
<p>
Se realiza una prueba de carga con los siguientes parámetros usando la herramienta Artillery:
</p>

<div class="org-src-container">
<pre class="src src-yaml">phases:
  - name: Ramp
    duration: 30
    arrivalRate: 1
    rampTo: 5
  - name: Plain
    duration: 60
    arrivalRate: 5
</pre>
</div>
</div>
<ol class="org-ol">
<li><a id="org8f2cc17"></a>Resultados observados<br />
<div class="outline-text-5" id="text-5-1-1-1">

<div id="orgb632ee9" class="figure">
<p><img src="./assets/rates1rps.png" alt="rates1rps.png" />
</p>
</div>

<p>
Para el escenario con una carga baja se observa el crecimiento sostenido y un posterior estado en el cual se mantiene constante la cantidad de request realizadas al servidor. Se observa que el máximo de la cantidad reportada de request son unas 50 y una media de 36.3 request por segundo.
</p>


<div id="orgf0d9c0d" class="figure">
<p><img src="./assets/rates1state.png" alt="rates1state.png" />
</p>
</div>

<p>
También se logra observar que en un escenario con carga baja, el servidor consigue responder satisfactoriamente a todas las consultas realizadas sin presentar fallos.
</p>


<div id="org1b8d5e0" class="figure">
<p><img src="./assets/rates1rpt.png" alt="rates1rpt.png" />
</p>
</div>

<p>
Del lado del cliente se aprecian dos medidas en el tiempo de respuesta, el máximo registrado y la media del tiempo de respuesta. En la totalidad de la prueba de carga se la media se mantiene en un rango de 4-6 ms sin variar de manera brusca, a su vez, el máximo del tiempo de respuesta tiene una media 19.6 ms y se reduce drásticamente en el momento en el que el servidor alcanza su máxima cantidad de carga, mismo punto en el que alcanza un máximo, el cual corresponde a 28.2 ms.
</p>


<div id="org12437a1" class="figure">
<p><img src="./assets/rates1resources.png" alt="rates1resources.png" />
</p>
</div>

<p>
Finalmente en un escenario de carga baja, el sistema se encuentra usando recursos casi constantes, las variaciones en el uso del CPU se encuentra en un rango de 0.5% a 0.6% y la memoria a su vez usa un porcentaje aún menor encontrándose en un rango de 0.071% a 0.074%.
</p>

<p>
En conclusión, analizando los gráficos y leyendo el resumen dado del comportamiento de la API, se realizaron 390 consultas al endpoint <code>rates</code> de las cuales todas fueron contestadas de manera satisfactoria.
</p>
</div>
</li>
</ol>
</div>
<div id="outline-container-org31aad64" class="outline-4">
<h4 id="org31aad64"><span class="section-number-4">5.1.2.</span> Prueba con mayor carga</h4>
<div class="outline-text-4" id="text-5-1-2">
<p>
A continuación se realiza una prueba de estrés más intensa sobre la API, específicamente en el endpoint <code>rates</code>, con el objetivo de analizar el comportamiento del sistema bajo condiciones de alta demanda y cómo esto impacta en los atributos de calidad, tales como disponibilidad, rendimiento y uso de recursos.
</p>

<p>
Se incrementa significativamente la cantidad de solicitudes por segundo, simulando un escenario donde múltiples usuarios acceden simultáneamente al servicio. Los resultados permiten identificar el punto de saturación del sistema, posibles errores en las respuestas y variaciones en los tiempos de respuesta y consumo de recursos.
</p>

<p>
Para esto se recurre nuevamente a la herramienta Artillery, esta vez modificando la configuración anterior por la siguiente:
</p>

<div class="org-src-container">
<pre class="src src-yaml">phases:
  - name: Ramp
    duration: 30
    arrivalRate: 0
    rampTo: 1000
  - name: Plain
    duration: 60
    arrivalRate: 600
</pre>
</div>
</div>
<ol class="org-ol">
<li><a id="org69734dd"></a>Resultados observados<br />
<div class="outline-text-5" id="text-5-1-2-1">

<div id="org26d6358" class="figure">
<p><img src="./assets/rates2rps.png" alt="rates2rps.png" />
</p>
</div>

<p>
En un escenario de mayor carga se observa un crecimiento sostenido en la cantidad de request por segundos, una reducción y estabilización de la misma, en esta ocasión el gráfico no permite realizar conclusiones sobre el estado de la aplicación.
</p>


<div id="org1aa9098" class="figure">
<p><img src="./assets/rates2state.png" alt="rates2state.png" />
</p>
</div>

<p>
En cambio, en el gráfico del estado de las respuestas se observa un crecimiento en la cantidad de respuestas correctas del servidor, pero durante la etapa de llegada constante de la cantidad de request por segundo se observa la aparición de casos de error en las respuestas a los clientes, indicando claramente que el servidor alcanza un límite en la cantidad de clientes que puede atender.
</p>


<div id="orgf9c1966" class="figure">
<p><img src="./assets/rates2rpt.png" alt="rates2rpt.png" />
</p>
</div>

<p>
Para el tiempo de respuestas se observa que una vez el servidor empieza a responder con códigos de error para los clientes, inicia un crecimiento acelerado en los máximos de tiempo de respuesta registrados, para el máximo, la media alcanza 1.46s y el máximo ahora alcanza casi los 10s para poder completar una consulta, mientras que para la media, se observa un crecimiento parecido. Esto indica claramente que el servidor presenta saturación de clientes y no permite responder adecuadamente a todos los clientes que intentan realizar una consulta sobre este endpoint.
</p>


<div id="org83a5025" class="figure">
<p><img src="./assets/rates2resources.png" alt="rates2resources.png" />
</p>
</div>

<p>
A su vez, los resultados observados para los recursos utilizados, en primer lugar para la memoria, se observa un aumento en comparación al test anterior pero no representa un uso excesivo de la misma, haciendo uso de la memoria RAM en un rango de 0.188% a 0.194%. Por el contrario esta vez el CPU alcanza el máximo de su uso rápidamente, llegando a usar un 35.7%, esto antes de alcanzar el máximo en la cantidad de request realizados al servidor, sin embargo a partir de haber alcanzado el límite el uso del CPU desciende rápidamente y a pesar de anteriormente haber observado respuestas con errores en los clientes y no se observaría una relación con el uso de recursos excesivos, es decir, la aplicación no alcanza un límite en el uso de los recursos disponibles.
</p>
</div>
</li>
<li><a id="org066bf69"></a>Conclusión<br />
<div class="outline-text-5" id="text-5-1-2-2">
<p>
En conclusión en un escenario de carga alta el servidor no es capaz de atender a todos los clientes de manera eficiente y afectando completamente la disponibilidad del servicio, el cual es un atributo de calidad clave y uno de los que se desea mejorar para incrementar la percepción positiva de la aplicación por parte de los clientes.
</p>
</div>
</li>
</ol>
</div>
<div id="outline-container-org3d1508c" class="outline-4">
<h4 id="org3d1508c"><span class="section-number-4">5.1.3.</span> Resumen de métricas de Artillery</h4>
<div class="outline-text-4" id="text-5-1-3">
<p>
Para la prueba de carga baja (salidarates1.txt):
</p>

<ul class="org-ul">
<li>Total de solicitudes: 390</li>
<li>Todas respondidas con código 200 (sin fallos)</li>
<li>Tiempo de respuesta medio: 1.1 ms, mediana: 1 ms, p95: 2 ms, p99: 2 ms</li>
</ul>

<p>
Para la prueba de carga alta (salidarates2.txt):
</p>

<ul class="org-ul">
<li>Total de solicitudes: 45000</li>
<li>Respuestas exitosas: 35944 (con 9056 errores ECONNRESET)</li>
<li>Tiempo de respuesta medio: 321.2 ms, mediana: 16 ms, p95: 2836.2 ms, p99: 4492.8 ms</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-org9576afb" class="outline-2">
<h2 id="org9576afb"><span class="section-number-2">6.</span> Propuestas de mejora</h2>
<div class="outline-text-2" id="text-6">
</div>
<div id="outline-container-orgd0a5bec" class="outline-3">
<h3 id="orgd0a5bec"><span class="section-number-3">6.1.</span> Implementacion de Valkey como persistencia</h3>
<div class="outline-text-3" id="text-6-1">
</div>
<div id="outline-container-orgb1ec94d" class="outline-4">
<h4 id="orgb1ec94d"><span class="section-number-4">6.1.1.</span> Tactica aplicada</h4>
<div class="outline-text-4" id="text-6-1-1">
<p>
La implementación utiliza Valkey como almacén de datos centralizado, reemplazando la persistencia en archivos JSON. Los datos se almacenan como claves en Redis:
</p>

<ul class="org-ul">
<li><code>accounts</code>: Almacena la lista de cuentas de usuario en formato JSON.</li>

<li><code>rates</code>: Contiene las tasas de cambio entre monedas.</li>

<li><code>log</code>: Registra el historial de transacciones realizadas.</li>
</ul>

<p>
El módulo <code>valkey.js</code> proporciona funciones asíncronas para inicializar la conexión (<code>init()</code>), obtener datos (<code>getAccounts()</code>, <code>getRates()</code>, <code>getLog()</code>) y actualizarlos (<code>setAccounts()</code>, <code>setRates()</code>, <code>setLog()</code>). Estas funciones serializan/deserializan los datos a JSON para almacenarlos como strings en Redis.
</p>

<p>
En <code>exchange.js</code>, se importa y utiliza este módulo para todas las operaciones de persistencia, reemplazando las lecturas/escrituras directas a archivos. La inicialización se realiza al inicio de la aplicación con <code>await valkeyInit()</code>.
</p>
</div>
</div>
<div id="outline-container-org13b5ce1" class="outline-4">
<h4 id="org13b5ce1"><span class="section-number-4">6.1.2.</span> Configuracion</h4>
<div class="outline-text-4" id="text-6-1-2">
<p>
Se agregó un servicio <code>valkey</code> en el <code>docker-compose.yml</code> utilizando la imagen <code>valkey/valkey:8.1.4-alpine</code>, expuesto en el puerto 6379. La aplicación se conecta mediante la variable de entorno <code>VALKEY_URL=redis://valkey:6379</code>.
</p>
</div>
</div>
<div id="outline-container-org25b5022" class="outline-4">
<h4 id="org25b5022"><span class="section-number-4">6.1.3.</span> Beneficios</h4>
<div class="outline-text-4" id="text-6-1-3">
<p>
Al centralizar el estado en Valkey, múltiples instancias de la API pueden compartir el mismo almacén de datos. Esto elimina la dependencia de estado local en memoria o archivos, permitiendo:
</p>

<ul class="org-ul">
<li>Escalado horizontal sin pérdida de consistencia.</li>

<li>Persistencia real de los datos, sobreviviente a reinicios de contenedores.</li>

<li>Operaciones atómicas en Redis para transacciones financieras.</li>
</ul>

<p>
Esta táctica mejora significativamente la Disponibilidad y Escalabilidad, mitigando los puntos únicos de falla relacionados con la persistencia local.
</p>


<div id="org28ea968" class="figure">
<p><img src="assets/componentes-modificados.png" alt="componentes-modificados.png" />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org3b9166c" class="outline-3">
<h3 id="org3b9166c"><span class="section-number-3">6.2.</span> Implementacion de PostgreSQL como persistencia</h3>
<div class="outline-text-3" id="text-6-2">
</div>
<div id="outline-container-org8dce938" class="outline-4">
<h4 id="org8dce938"><span class="section-number-4">6.2.1.</span> Tactica aplicada</h4>
<div class="outline-text-4" id="text-6-2-1">
<p>
La implementación utiliza PostgreSQL como almacén de datos relacional, reemplazando la persistencia en archivos JSON y Valkey. Las tablas creadas son:
</p>

<ul class="org-ul">
<li><code>accounts</code>: Almacena las cuentas de usuario con campos como id, currency, balance, created<sub>at</sub>, updated<sub>at</sub>, deleted.</li>

<li><code>exchange_rates</code>: Contiene las tasas de cambio entre monedas con base<sub>currency</sub>, counter<sub>currency</sub>, rate, updated<sub>at</sub>.</li>

<li><code>transactions</code>: Registra el historial de transacciones realizadas, con soporte para atomicidad en operaciones de intercambio.</li>
</ul>

<p>
El módulo <code>databaseAdapter.js</code> proporciona funciones para conectarse a PostgreSQL usando el paquete <code>pg</code>, manejando conexiones y transacciones. Los modelos en <code>models/</code> (Account, ExchangeRate, Transaction) manejan las operaciones CRUD con soporte para transacciones ACID.
</p>

<p>
En <code>exchange.js</code>, se utilizan estos modelos para todas las operaciones financieras, incluyendo transacciones atómicas para intercambios que requieren consistencia (ej. actualizar balances y registrar transacción en una sola operación).
</p>
</div>
</div>
<div id="outline-container-org0b23335" class="outline-4">
<h4 id="org0b23335"><span class="section-number-4">6.2.2.</span> Configuracion</h4>
<div class="outline-text-4" id="text-6-2-2">
<p>
Se agregó un servicio <code>postgres</code> en el <code>docker-compose.yml</code> utilizando la imagen <code>postgres:15-alpine</code>, con inicialización de la base de datos mediante el script <code>01-init.sql</code> que crea las tablas, índices y datos iniciales.
</p>

<p>
Se configuraron tres instancias de la API (<code>api1</code>, <code>api2</code>, <code>api3</code>) conectadas a PostgreSQL, permitiendo escalado horizontal sin pérdida de estado.
</p>

<p>
Se actualizó <code>nginx_reverse_proxy.conf</code> para balancear carga entre las tres instancias de API utilizando un bloque <code>upstream</code>.
</p>
</div>
</div>
<div id="outline-container-orgd1feacc" class="outline-4">
<h4 id="orgd1feacc"><span class="section-number-4">6.2.3.</span> Beneficios</h4>
<div class="outline-text-4" id="text-6-2-3">
<p>
Al centralizar el estado en PostgreSQL con transacciones ACID, múltiples instancias pueden compartir el mismo almacén de datos de forma consistente y atómica. Esto elimina dependencias de estado local, permite escalado horizontal sin pérdida de consistencia, y asegura atomicidad en operaciones financieras críticas, mejorando la integridad de datos.
</p>

<p>
Esta táctica mejora significativamente la Disponibilidad (reduciendo puntos únicos de falla en persistencia), Escalabilidad (permitiendo más nodos con estado compartido), y Performance (con transacciones eficientes, concurrencia controlada y consultas optimizadas con índices).
</p>


<div id="org9185720" class="figure">
<p><img src="assets/componentes-postgresql.png" alt="componentes-postgresql.png" />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org032b3e5" class="outline-3">
<h3 id="org032b3e5"><span class="section-number-3">6.3.</span> Comparacion de estados de requests</h3>
<div class="outline-text-3" id="text-6-3">

<div id="org5bcf509" class="figure">
<p><img src="assets/request-state-base.png" alt="request-state-base.png" />
</p>
<p><span class="figure-number">Figura 10: </span>Estado de requests en la arquitectura base</p>
</div>

<p>
En la arquitectura base, se observa una alta tasa de errores debido a la sobrecarga de la única instancia de la API y problemas de concurrencia en el acceso a archivos JSON locales, lo que resulta en fallos de conexión y respuestas erróneas bajo carga elevada.
</p>


<div id="org1c0a534" class="figure">
<p><img src="assets/request-state-postgresql.png" alt="request-state-postgresql.png" />
</p>
<p><span class="figure-number">Figura 11: </span>Estado de requests con la propuesta de mejora (PostgreSQL y balanceo de carga)</p>
</div>

<p>
Con la propuesta de mejora que incluye balanceo de carga entre tres nodos y PostgreSQL como persistencia, la tasa de errores se reduce significativamente. El balanceo de carga distribuye la carga uniformemente entre los nodos, evitando la saturación de un solo punto, mientras que PostgreSQL maneja mejor la concurrencia mediante transacciones ACID y acceso controlado a la base de datos, minimizando errores por conflictos de acceso a datos y mejorando la estabilidad general del sistema.
</p>
</div>
</div>
</div>
<div id="outline-container-org40f32f4" class="outline-2">
<h2 id="org40f32f4"><span class="section-number-2">7.</span> Trade-offs detectados.</h2>
</div>

<div id="outline-container-org72d4ab6" class="outline-2">
<h2 id="org72d4ab6"><span class="section-number-2">8.</span> Pedido Adicional (Volumen de transacciones por moneda)</h2>
</div>

<div id="outline-container-orgae037ba" class="outline-2">
<h2 id="orgae037ba"><span class="section-number-2">9.</span> Conclusiones</h2>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2025-10-09 Thu 19:11</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
